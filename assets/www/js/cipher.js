/*************************************************************************************************************************/
/*** JAVASCRIPT TO MANAGE THE CRYPTOGRAPHY NEEDED TO ACHIEVE CONFIDENTIALITY, INTEGRITY AND NON-REPUDIATION OF THE SMS ***/
/*************************************************************************************************************************/

// Length of a curve 25519 key (32 bits) in Base64 format
var curve25519KeyLengthB64 = 44;
// Length of a curve 25519 key (32 bits)
var curve25519KeyLength = 32;


// Convert a String to Hexadecimal
function convertStringToHex(str) {
    var result = '';
    for (var i=0; i<str.length; i++) {
      result += str.charCodeAt(i).toString(16);
    }
    return result;
  }

// Convert a Hexadecimal to a String
function convertHexToString(hex) {
    var hex = hex.toString();
    var str = '';
    for (var i = 0; i < hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}

// Return true o false depending on whether the String sent as parameter is encoded in Base64
function isStringBase64(text){
    var patterStringB64 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    return patterStringB64.test(text);
}

// Return true o false depending on whether the String only have characters in Base64
// The difference between this function and the previous one is that this function check if the String only have characters Base64,
// but the previous one check that the String is encoded in Base64
function isStringOnlyCharactersBase64(text){
    var patterStringB64 = /^[0-9a-zA-Z+/=]*$/;
    return patterStringB64.test(text);
}

// Function to know if a phone has a correct format or not
function isCorrectPhone(phone){
    var patternTlf = /^[\+]{1}[0-9]*$/;
    var isCorrect = 1;
    if (patternTlf.test(phone) == false){
        isCorrect = 0;
    }

    return isCorrect;
}

// Check whether all parameters sent, when a new contact is created manually, are correct
function checkInputKeysWellFormed(phone,nRSA,eRSA,myPublicKey,mySecretKey,contactPublicKey){
    var result = new Object();
    result.message = "";
    result.error = 0;

    var patternOnlyNumbers = /^[0-9]+$/;
    var patterStringB64 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;

    if (patternOnlyNumbers.test(nRSA) == false){
        result.error = 1;
        result.message = result.message+"The variable 'n' must be formed only by numbers. ";
    }
    if (patternOnlyNumbers.test(eRSA) == false){
        result.error = 1;
        result.message = result.message+"The variable 'e' must be formed only by numbers. ";
    }

    if (patterStringB64.test(myPublicKey) == false || myPublicKey.length != 44){
        result.error = 1;
        result.message = result.message+"The public ephemeral key generated for that contact must be encoded in Base64 and its length must be 44 characters. ";
    }
    if (patterStringB64.test(mySecretKey) == false || mySecretKey.length != 44){
        result.error = 1;
        result.message = result.message+"The secret ephemeral key generated for that contact must be encoded in Base64 and its length must be 44 characters. ";
    }
    if (patterStringB64.test(contactPublicKey) == false || (contactPublicKey.length != 44 && contactPublicKey.length != 0)){
        result.error = 1;
        result.message = result.message+"The public ephemeral key generated by the contact must be encoded in Base64 and its length must be empty or has 44 characters. ";
    }
    return result;
}

// Function to cipher plain text with a key using the operation mode CBC
function cipherPlainText(plainText, key) {
    var cipherText = "";

    try {
        var iv = forge.random.getBytesSync(curve25519KeyLength);
        var ivBase64 = btoa(iv);

        var cipher = forge.cipher.createCipher('AES-CBC', key);
        cipher.start({iv: iv});
        cipher.update(forge.util.createBuffer(plainText));
        cipher.finish();
        var encrypted = cipher.output;

        var bytes = forge.util.hexToBytes(encrypted.toHex());
        var bytesBase64 = btoa(bytes);

        cipherText = ivBase64 + bytesBase64;
    } catch (err) {
        console.log("Cipher the plain text has been imposible: "+err.message);
    }
    return cipherText;
}

// Function to decipher cipher text with a key using the operation mode CBC
function decipherCipherText(cipherText, key){
    var plainText = "";

    try {
        var ivBase64 = cipherText.substring(0,curve25519KeyLengthB64);
        var iv = atob(ivBase64);

        var cipherTextWithoutIV = cipherText.substring(curve25519KeyLengthB64,cipherText.length);
        var bytesCipherText = atob(cipherTextWithoutIV);
        var BufferArrayCipherText = forge.util.createBuffer(bytesCipherText);

        var decipher = forge.cipher.createDecipher('AES-CBC', key);
        decipher.start({iv: iv});
        decipher.update(BufferArrayCipherText);
        decipher.finish();

        var plainTextHex = decipher.output.toHex();
        plainText = convertHexToString(decipher.output.toHex());
    }
    catch (err) {
        console.log("Deciphering cipher text has been imposible: "+err.message);
    }
    return plainText;
}

// Calculate shared key (in Bytes) from public Key y Secret Key (in Base 64)
function calculateSharedKey(publicKey, secretKey){
    var sharedKey = "";

    try {
        var publicKeyBytes = atob(publicKey);
        var publicKeyUnit8Array = fromBytesToUnit8Array(publicKeyBytes);

        var secretKeyBytes = atob(secretKey);
        var secretKeyUnit8Array = fromBytesToUnit8Array(secretKeyBytes);

        var shareKeyArray = nacl.box.before(publicKeyUnit8Array, secretKeyUnit8Array);
        sharedKey = fromUnit8ArrayToBytes(shareKeyArray);
    }
    catch (err){
        console.log("Calculating shared key has been impossible. There is an error in Public Key or in Secret Key: "+err.message);
    }
    return sharedKey;
}

// Sign a STRING with a private key. The String will have in Base64:
//     CipherText +
//     My new Public Key (curve 25519) for that contact  +
//     Last public Key (curve 25519) received from that contact
function signCipherText(cipherText, privateKey) {
    var signatureB64 = "";

    try {
        var md = forge.md.sha256.create();
        md.update(cipherText, 'utf8');
        var signature = privateKey.sign(md);
        signatureB64 = btoa(signature);
    } catch (err) {
        console.log("Signing text has been impossible. There is an error in Private Key: "+err.message);
    }
    return signatureB64;
}

// Function to verify if the signature of a String is correct.
//   Public RSA key, the signature and the signed data will be necessaries as parameter.
//   function return true or false whether the signature is correct or not.
function verifySignature(publicKey, signatureB64, dataB64) {
    var signature = atob(signatureB64);
    var md = forge.md.sha256.create();
    md.update(dataB64, 'utf8');
    var verified;
    try {
       verified  = publicKey.verify(md.digest().getBytes(), signature);
    }
    catch(err){
       verified = false;
       console.log("Verifying sign has been impossible. The text will not be deciphered: "+err.message);
    }
    return verified;
}

// Function to obtain the length of a signature depending on the length of the public RSA Key
function getSignLength(nLength){
    var signLength = 0;
    if (nLength == 19){ // 512 key length
        signLength = 88;
    } else if (nLength == 37){ // 1024 key length
        signLength = 172;
    } else if (nLength == 74){ // 2048 key length
        signLength = 344;
    }
    return signLength;
}

// Function to obtain the text, which will be sent in order to communicate public keys (permanent and ephemeral) and ask the receiver keys
function getTextForSendingAndObtainingKeys(publicEphemeralKey,requireKeys){
    var nRSA = getNRSABase35();
    var eRSA = getERSABase35();
    var specialCharacter = '';
    if (requireKeys == true){
        specialCharacter = '?';
    } else {
        specialCharacter = '!';
    }
    return specialCharacter + nRSA + ',' + eRSA + ',' + publicEphemeralKey;
}

// Function to obtain the plain text from a cipher and sign text generated with the next function
//   - This function check that the signature is correct
//   - Obtain last public key curve 25519 received by the contact and delete the previous ones. The secret key associated to this key will be use to generate the shared key.
//   - Obtain the public key used to generated by the sender. This key will be used to generate the shared key.
//   - Obtain the plain text using the shared key before
function getPlainTextFromSignAndCipherText(phone,text,callback){
    var data= new Object();
        data.plainText = "";
        data.error = 0;

    if (text.substring(0,1) == '@'){
        var textWithoutSpecialCharacter = text.substring(1,text.length);

        /* The message must be completely encoded in base64 format */
        if (isStringOnlyCharactersBase64(textWithoutSpecialCharacter)){
            var publicKeyContact = getPublicKeyRSAContact(phone);
            var signLength = getSignLength(publicKeyContact.n.t);

            var signature = textWithoutSpecialCharacter.substring(0, signLength);
            var textSigned = textWithoutSpecialCharacter.substring(signLength, textWithoutSpecialCharacter.length);
            var verifiedText = verifySignature(publicKeyContact,signature,textSigned);

            if (verifiedText == true){
                // Obtain last public Key received
                var lastPublicKeyReceived = textWithoutSpecialCharacter.substring(signLength, signLength+curve25519KeyLengthB64);

                // delete public keys previous
                deletePreviousEphemeralKeys(phone,lastPublicKeyReceived,function(){
                    // Obtain the secret key that corresponds with last Public Key Received
                    var secretKey = getSecretKeyFromContact(phone,lastPublicKeyReceived);
                    if (secretKey.length == curve25519KeyLengthB64){
                        // Obtain public key generated by the sender
                        var publicKeyContact = textWithoutSpecialCharacter.substring(signLength + curve25519KeyLengthB64, signLength + curve25519KeyLengthB64 + curve25519KeyLengthB64);
                        // Update public key sent by the sender
                        writeNewPublicEphemeralKeyReceived(phone,publicKeyContact,function(){
                            // Obtain Shared Key with the public key generated by the sender and my secret key
                            var sharedKey = calculateSharedKey(publicKeyContact, secretKey);

                            if (sharedKey.length == curve25519KeyLength) {
                               // Obtain Cipher Text
                               var cipherText = textWithoutSpecialCharacter.substring(signLength + curve25519KeyLengthB64 + curve25519KeyLengthB64, textWithoutSpecialCharacter.length);

                                // Obtain Plain Text from Cipher Text and Shared Key calculated before
                                data.plainText = decipherCipherText(cipherText, sharedKey);
                                if (data.plainText.length <= 0){
                                    alert("Deciphering the cipher has been impossible. Shared Key may have an error.");
                                    data.error = 8;
                                }
                                callback(data);
                            }
                            else {
                                alert("Calculating shared key has been impossible. There is an error in Public Key or in Secret Key.");
                                data.error = 7;
                                callback(data);
                            }
                        });
                    } else {
                        alert("The contact public key received is not found in our database. The text cannot be deciphered.");
                        data.error = 6;
                        callback(data);
                    }
                });
            } else {
                alert("The signature of received text is wrong. The text will not be deciphered.");
                data.error = 5;
                callback(data);
            }
        } else {
            alert("An message has been received, but it is not encoded in base64 format.");
            data.error = 4;
            callback(data);
        }
    } else if (text.substring(0,1) == '?'){
        data.error = 1;
        callback(data);
    } else if (text.substring(0,1) == '!'){
        data.error = 2;
        callback(data);
    } else {
        alert("The message received does not start with the special character '@' or '?'.");
        data.error = 3;
        callback(data);
    }
}

// Function to get the text, which will be sent in a sms. This text will have:
//      - The signature encoded in base64
//      - The last public key received, that also has been used to generate the shared key to cipher the plain text
//      - The new secret key generated for that contact
//      - The text cipher using the algorithm AES with the shared key calculated previously
function createTextCipheredAndSign(phone,plainText,callback){
    var data = new Object();

    // variable to return the information ciphered and signed
    data.cipherTextWithPublicKeysAndSignature = "";
    data.error = 0;

    // Obtain public key for the contact
    var publicKeyContact = getPublicEphemeralKeyContact(phone);

    if (publicKeyContact.length == curve25519KeyLengthB64){
        // Generate a new key pair curve 25519 and write it in Memory and the DataBase
        var keyPairCurve25519 = generateKeyPairCurve25519();
        writeContactEphemeralKeysDataBase(phone,keyPairCurve25519.secretKey,keyPairCurve25519.publicKey,function(id){
            writeNewContactEphemeralKeysMemory(phone, keyPairCurve25519.secretKey, keyPairCurve25519.publicKey, id);

            // Obtain Shared Key with the public key generated by the sender and my secret key
            var sharedKey = calculateSharedKey(publicKeyContact, keyPairCurve25519.secretKey);
            if (sharedKey.length == curve25519KeyLength) {
                // Obtain Cipher Text with Shared Key
                var cipherText = cipherPlainText(plainText,sharedKey);
                if (cipherText.length > 0){
                    // Obtain Private RSA Key in order to sign the information
                    var privateRSAKey = getRSAPrivateKey();

                    var signLength = getSignLength(privateRSAKey.n.t);

                    // Obtain the signature for last public key received, my new public key and cipher text
                    var signature = signCipherText(publicKeyContact+keyPairCurve25519.publicKey+cipherText,privateRSAKey);

                    if (signature.length == signLength){
                        // Create a String with:
                        //      1 - Signature
                        //      2 - Last public ephemeral key received from the contact
                        //      3 - My new public ephemeral key
                        //      4 - Cipher Text
                        data.cipherTextWithPublicKeysAndSignature = '@' + signature + publicKeyContact + keyPairCurve25519.publicKey + cipherText;
                    } else {
                        alert("Signing text has been impossible. There is an error in Private Key.");
                    }
                } else {
                    alert("Ciphering has been impossible. Shared Key may have an error.");
                    data.error = 1;
                }
            } else {
                alert("Calculating shared key has been impossible. There is an error in Public Key or in Secret Key.");
                data.error = 1;
            }
            callback(data);
        });
    } else {
        alert("The public key for that contact does not have the correct length. The text cannot be ciphered.");
        data.error = 1;
    }
}
